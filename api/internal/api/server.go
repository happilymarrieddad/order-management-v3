package api

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gorilla/handlers"
	"github.com/gorilla/mux"
	_ "github.com/happilymarrieddad/order-management-v3/api/docs" // docs is generated by Swag CLI
	"github.com/happilymarrieddad/order-management-v3/api/internal/api/auth"
	"github.com/happilymarrieddad/order-management-v3/api/internal/api/middleware"
	"github.com/happilymarrieddad/order-management-v3/api/internal/api/public"
	v1 "github.com/happilymarrieddad/order-management-v3/api/internal/api/v1"
	"github.com/happilymarrieddad/order-management-v3/api/internal/repos"
	httpSwagger "github.com/swaggo/http-swagger"
)

// Run starts the API server. It configures routes, middleware, and handles graceful shutdown.
// This function will block until the server is shut down.
func Run(repo repos.GlobalRepo, logger *log.Logger) error {
	router := mux.NewRouter()

	router.Use(middleware.RepoMiddleware(repo))

	// Add swagger route. Access it at http://localhost:8080/swagger/index.html
	// The empty import of the docs package is necessary for swag to work.
	router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

	router.HandleFunc("/login", auth.Login).Methods("POST")

	// Add public routes that do not require authentication
	public.AddPublicRoutes(router)

	// All routes under /api require authentication
	api := router.PathPrefix("/api").Subrouter()
	api.Use(middleware.AuthMiddleware)

	// Create a subrouter for v1 of the API
	v1Routes := api.PathPrefix("/v1").Subrouter()
	// Delegate all v1 route definitions to the v1 package
	v1.AddAuthRoutes(v1Routes)

	// --- Server Setup & Graceful Shutdown ---
	serverAddr := ":8080"
	// Define the CORS options, allowing the custom X-App-Token header.
	corsOpts := handlers.CORS(
		handlers.AllowedOrigins([]string{"*"}), // Be more specific in production
		handlers.AllowedHeaders([]string{"X-Requested-With", "Content-Type", "Authorization", "X-App-Token"}),
		handlers.AllowedMethods([]string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}),
	)
	srv := &http.Server{
		Addr:         serverAddr,
		Handler:      handlers.LoggingHandler(os.Stdout, corsOpts(router)),
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	done := make(chan os.Signal, 1)
	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		logger.Printf("server starting on %s", serverAddr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Fatalf("listen: %s\n", err)
		}
	}()

	<-done
	logger.Println("server stopped")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		logger.Fatalf("server shutdown failed: %+v", err)
	}

	logger.Println("server exited properly")
	return nil
}
